
/*TODO 

		THIS TEXT IS OVER A YEAR OLD: ALL NEW CONTENT IN OTHER FILES 


		Develop basic game functionality
		World editor
		Events
		Person viewer		
		Set and display traits
		Family Trees
		
		UI:
			
			UI adapts to screen size
			Use repaint to draw filters
			Several filters simultaneously	
			
		iPad:

			Scrolling and Zooming
			
		A typical turn:
		
		 Read news
		 Deal with events
		  * Decide what characters to leave in charge of what
		 Identify a goal
		  * Capture new areas
		  * Build new alliances
		  * etc
		 Work towards goal
		  * Build wealth
		  * Develop owned lands
		  * Send characters as diplomats to other factions
		 End turn
		
		Features:
		 * Autogenerated continent sized world
		 * World is automatically populated with people and resources
		 * Two views: A "world" map and a "local" map.
		 * Cities, roads and settlements develop independently of player
		 * Player control a family and its allies through one character, the head of the dynasty.
		 * People have attributes and genetics
		 * Seasons
		 * Markets, "factories" and storehouses are used to build wealth 
		 * Random events
		 
		Ideas:
		
		 The player only controls one character, but the other family members may still act.
		 The player may give these characters resposibilities according to their skill sets. For instance:
		  * Head of Economy 	-	make sure that factories are efficient  
		  * Head of Diplomacy 	-	make sure that alliances are uphold
		  * Head of Defence, etc
		 The player can divide the empire into several sections, each with their own managements.
		 Could even use knights, squires and the like, each with their own responsibilities and rights.
		
		Spaces
		Add Resources
		Calculate Wealth, Fertility (using Proximity to water/land and other fertile/rich tiles)
		Calculate water volume (tiles connected as ocean), start with tiles surrounded by water.
		Do the same for forest, mountains etc.
		Make attempt at rivers
		Place population
		TileView
		Recipes
*/

/*
		Raw Resources:
			Grass: Wheat, Sheep, Horse, Cows,   
			Forest: Wood, Pigs, 
			Water: Fish, Sand, 
			Mountain: Stone, Iron, Copper, Coal
		Produce:
			Bread (wheat), Wool (sheep), Leather (cow), Clothes (wool, leather), Cooked Fish (fish), Meat (sheep, cows, pigs), 
			Cooked Meat (meat), Wooden Plank (wood), Weaponry (wood, stone, iron), Boat (wood, iron), Tamed Horse (horse), 
		Random Events:
			Disease spread, Dynasty Character dies, is born, is wounded, struck with disease, married etc., Flooding, Volcano eruption, 
			Assassination, Army Draft, War, Various religious events, various political events, 
		
			
*/

var lastSeason = season;
function getColorForTile(tile){
	var type = tile.type;
	var r,g,b;
	/*if(season == lastSeason && tile.color != undefined){
		return tile.color;
	}*/
	var seasonT = seasons[season];
	
	if(type == "water"){
		if(seasonT == "Winter"){
			r = 180 - (tile.depth-1)*8;
			g = 180 - (tile.depth-1)*8;
			b = 200 - (tile.depth-1)*2;
			if(b < 150) b = 150;	
		}
		else if(seasonT == "Spring"){
			var c = (tile.depth-1)*3;
			r = 10 - c;
			g = 120 - c;
			b = 255 - c;
		}
		else{
		r = 0;
		g = 0;
		b = 255 - (tile.depth-1)*10;
		if(b < 100) b = 100;
		}
		//return "rgb("+r+","+g+","+b+")";	
	}
	else if(type == "settlement"){
        r = random(80,152);
        g = 54;
        b = 51;
        if(tile.newSettlement){
            r += 60;
            g += 60;
        }	
	}
	else if(tile.road){
		r = 50; g = 99; b = 51;
	}
	else if(type == "grass"){
		var c = 10 + 2*(tile.depth);
		if(c > 200) c = 200;
		if(seasonT == "Winter"){
			r = Math.round(70+1.2*c);
			g = Math.round((153+c/2));
			b = (70+c);
		}
		else if(seasonT == "Spring"){
			r = Math.round(10+1.2*c);
			g = Math.round((133+c/2));
			b = (10+1.3*c);
		}
		else if(seasonT == "Fall"){
			r = Math.round(80+1.2*c);
			g = Math.round((133+c/2));
			b = (5+1.3*c);
		}
		else{
			r = Math.round(10+2*c);
			g = Math.round((133+c/2));
			b = (10+c);
		}
		//return "rgb("+r+","+g+","+b+")";
	}
	else if(type == "mountain"){
		var c = 150 + tile.depth*14;
		if(seasonT == "Winter"){
			r = 1.1*(c+10);
			g = 1.1*(c+10);
			b = Math.round(1.2*c+20);
		}
		else{
			r = c;
			g = c;
			b = Math.round(1.1*c);
		}
	}
	else if(type == "sand"){
		r = 255;
		g = 228;
		b = 156;
		//return "#FF9";	
	}
	else if(type == "river"){
		//return "rgb(50,50,255)";
	}
	else{ //forest
	
		var c = 2*tile.depth;
		if(seasonT == "Winter"){
			r = 0;
			g = (100-c);
			b = (50-c);
		}
		else if(seasonT == "Fall"){
			r = 30;
			g = (110-c);
			b = (20);
		}
		else{
			r = 0;
			g = (96-c);
			b = (48-c);
		}
		//return "rgb(0,"+g+","+b+")";////"#063"; //forest
	} 

	if(tile.ruin){
        r = 10;
        g = 10;
        b = 10;
    }
	
	if(r < 0) r = 0; if(r > 255) r = 255; if(g < 0) g = 0; if(g > 255) g = 255; if(b < 0) b = 0; if(b > 255) b = 255;
	//tile.color = "rgb("+Math.round(r)+","+Math.round(g)+","+Math.round(b)+")";
	return {"r":plusMinus(r,3),"b":plusMinus(b,3),"g":plusMinus(g,3)};
	return tile.color;
	
}

function resourceInfo(tile,resource)
{
	if(tile.resources[resource] > 0)
	{
		var t = $("<div></div>").addClass("resource").addClass(resource)
		.append("<span>"+ resourceData[resource].name +"</span>")
		.append("<div>"+ tile.resources[resource] + "</div>");
		return t;
	}
	else
	{
		return "";
	}
}

function fillActionMenu(tile){
	if(tile != undefined){
		$("#tileActions").append($("<div>").text("No actions available"));
		if(tile.type == "grass"){
			//build stuff!
			$("#tileActions").empty().append($("<div>").text("Start construction"));
		}
		else if(tile.type == "forest"){
			$("#tileActions").empty().append($("<div>").text("Send hunters or gatherers"));
		}
		else if(tile.type == "mountain"){
			//do prospecting
		}
		else if(tile.type == "water"){
			//fishing
		}
		
	}
	//$("#actionMenu").append($("<div>").text("Test"));
}
/*
function actionMenu(){
	var menu = $("<div>").addClass("menues").attr("id","actionMenu").css({"position":"absolute", "bottom":0,"left":0,"height":"33%","width":"20%","z-index":8});
	menu.append($("<div>").text("Available Actions:"));
	$("body").append(menu);
	fillActionMenu();
}
*/
function updateTileInfo(tile)
{
	/*Check if tile is owned*/
	/*If owned by someone else, hide certain information*/
	/*If owned by player, enable options*/
	/*If there's a factory constructed, show factory info*/
	$("#tileInfo .type").text(tile.type[0].toUpperCase() + tile.type.substr(1) + " Tile");
	$("#tileResources").empty();
	$.each(tile.resources, function(i, resource){
		$("#tileResources").append(resourceInfo(tile,i));
	});

	var population = tile.population;
	var value = tile.value;
	var id = "ID: " + tile.globalPosition.x + ", " + tile.globalPosition.y;
	forEachCity(function(city){
		try{
			city.showRange.hide();
		}
		catch(e){

		}
	});
	try{	
		var area = world.areas[tile.field];
		if(area.type == "settlement"){
			var city = tile.field;
			city = world.areas[city];
			population = city.population;
			//	value = city.value;
			id = "City " + tile.field;

			city.showRange.show();
		}	
	}
	catch(e){
		// field undefined or null or something
	}
	
	$("#tileValue").text(id + ". Tile Value: " + value);
	$("#tilePopulation").text("Tile Population: " + population);

	$("#tileActions").empty();
	//fillActionMenu(tile);
	$("#tileInfo").removeClass("hidden").show();
}

function tileClick(evt){ /*Click handler for svg. Deprecated*/
	tileClicked(getTileFromId(evt.target.id));
}

function clearCanvas(canvas, x,y,w,h){
	var ctx = canvas.getContext("2d");
	x = (x == undefined) ? 0 : x;
 	y = (y == undefined) ? 0 : y;
 	w = (w == undefined) ? canvas.width : w;
	h = (h == undefined) ? canvas.height : h;
	ctx.clearRect(x,y,w,h);
}

function changeOverlayCanvas(func,clear)
{ 
    overlayFunc = func;
    overlayActive = true;
	clear = (clear == undefined) ? false : clear;
	if(clear){ 
	   clearCanvas(overlay);
	}
    updateOverlayCanvas();
}
var overlayFunc;
var overlayActive = false;
function updateOverlayCanvas(){
    clearCanvas(overlay);
    if(!overlayActive || overlayFunc == undefined)  return;
    if(scale == world.tileSize){
        xScroll = 0;
        yScroll = 0;
    }

    var xTilesOnScreen = Math.ceil(w / scale);
    var yTilesOnScreen = Math.ceil(h / scale);      
    var xTileScroll = Math.floor(xScroll / scale);
    var yTileScroll = Math.floor(yScroll / scale);
    for(var x = xTileScroll; x <= xTileScroll+xTilesOnScreen; x+=resolution){
        for(var y = yTileScroll; y <= yTileScroll+yTilesOnScreen; y+=resolution){
            if(x < 0 || x >= world.sizeX || y < 0 || y >= world.sizeY){ 
                continue;
            }
            var color = overlayFunc(x,y);
            if(color.a != 0){
                drawSingleTile(cctx, x, y, color);
            }
        }
    }
}

//useful zoomlevels: scale = 4 (entire world), scale = 20 (zoomlevel = 5)
var scale;
var fog = false;
var range = 100;
function drawSingleTile(cctx, x, y, fillColor, strokeColor){
	
	var xStart = x*scale - xScroll;
	var yStart = y*scale - yScroll;
	var xEnd = (x+1)*(scale) - xScroll;
	var yEnd = (y+1)*(scale) - yScroll;
	var tileWidth = scale-0.001;
	var tileHeight = scale-0.001;
	if(xStart < 0){ tileWidth += xStart; xStart = 0; }
	if(yStart < 0){ tileHeight += yStart; yStart = 0; }
	if(xEnd > w*2){ tileWidth -= xEnd-w; }
	if(yEnd > h*2){ tileHeight -= yEnd-h; }

	cctx.lineWidth = 0;
	cctx.fillStyle = fillColor;
    cctx.strokeStyle = fillColor; //for now
	cctx.fillRect(xStart,yStart,tileWidth, tileHeight);
	cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
	
	var sourceX,sourceY,distance,inrange;
	if(fog){
		sourceX = world.dynasty.root.location.globalPosition.x;
		sourceY = world.dynasty.root.location.globalPosition.y
		distance = Math.sqrt(Math.pow(sourceX-x,2) + Math.pow(sourceY-y,2));
		
		inrange = distance < range;
		if(!inrange){
		if(distance > 100){
			distance = 100;
		}
		cctx.fillStyle = cctx.strokeStyle = "rgba(0,0,0,"+distance/100+")";
		cctx.fillRect(xStart,yStart,tileWidth, tileHeight);
		cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
		}
	}
	//draw borders
	//draw resources!
	/*if(world.tiles[x][y].resources != undefined && world.tiles[x][y].resources["pigs"] != undefined){
		cctx.fillStyle = "pink";
		cctx.fillRect(xStart + x%(tileWidth-1), yStart + y%(tileHeight-1),1,1);
	}*/
    if(filters && filters.length > 0){
        var tile = world.tiles[x][y];
        $.each(filters, function(i,val){
            var color = val(tile,cctx,xStart,yStart);
            if(color){
                cctx.fillStyle = color;
                cctx.strokeStyle = color;
                cctx.fillRect(xStart,yStart,tileWidth,tileHeight);
            }
        });
    }
    if(tile.special){
    	$.each(tile.special, function(i,val){
    		var color = val(tile,cctx,xStart,yStart);
            if(color){
                cctx.fillStyle = color;
                cctx.strokeStyle = color;
                cctx.fillRect(xStart,yStart,tileWidth,tileHeight);
            }
    	});
    }
	if((!fog || inrange) && world.tiles[x][y].type == "settlement" && world.tiles[x][y].borders != null){

		cctx.fillStyle = "gray";
		for(var i = 0; i < world.tiles[x][y].borders.length; i++){
			var border = world.tiles[x][y].borders[i];
			if(border == "left"){
				cctx.fillRect(xStart,yStart,2,tileHeight);
			}
			else if(border == "right"){
				cctx.fillRect(xStart+tileWidth-2,yStart,2,tileHeight);
			}
			else if(border == "above"){
				cctx.fillRect(xStart,yStart,tileWidth,2);
			}
			else if(border == "below"){
				cctx.fillRect(xStart, yStart+tileHeight-2,tileWidth,2);
			}
		}
	}
	
	//ctx.rect(xStart,yStart,tileWidth,tileHeight);
	//ctx.closePath();
	//ctx.fill();
	//ctx.stroke();
}

var canvas;
var cctx;

function benchMark(){
	for(var i = 0; i < 10; i++){
		repaint2();
	}
}

function repaint2(worldToDraw){
    updateOverlayCanvas();
	processingInstance.redraw();
}


var resolution = 1;
function sketchProc(processing) {
   	// Override draw function, by default it will be called 60 times per second
	processing.setup = function(){
		processing.size(window.w,window.h, processing.P2D);
		processing.noLoop();
	}
	processing.draw = function() {
 
    function drawTile(tile) {
       	if(tile == undefined) return;
       	var x = tile.globalPosition.x;
       	var y = tile.globalPosition.y;
		var xStart = x;//*scale - xScroll;
		var yStart = y;//*scale - yScroll;
		var xEnd = (x+resolution);//*(scale) - xScroll;
		var yEnd = (y+resolution);//*(scale) - yScroll;
		var tileWidth = scale * resolution;//-0.001;
		var tileHeight = scale * resolution;//-0.001;
		if(xStart < 0){ tileWidth += xStart; xStart = 0; }
		if(yStart < 0){ tileHeight += yStart; yStart = 0; }
		if(xEnd > w*2){ tileWidth -= xEnd-w; }
		if(yEnd > h*2){ tileHeight -= yEnd-h; }
		var color = getColorForTile(tile);
		processing.fill(color.r, color.g, color.b);	
		processing.rect(xStart,yStart,tileWidth,tileHeight);
		//drawImage
		//cctx.strokeRect(xStart+2,yStart+2,tileWidth-2, tileHeight-2);
    }
 	
    // erase background
    processing.background(224);
 	processing.noStroke();
	if(world == undefined) return;
	var t1 = new Date();
	if(scale == world.tileSize){
		xScroll = 0;
		yScroll = 0;
	}

	processing.translate(-xScroll,-yScroll);
	processing.scale(scale);
	var xTilesOnScreen = Math.ceil(w / scale);
	var yTilesOnScreen = Math.ceil(h / scale);		
	var xTileScroll = Math.floor(xScroll / scale);
	var yTileScroll = Math.floor(yScroll / scale);
	for(var x = xTileScroll; x <= xTileScroll+xTilesOnScreen; x+=resolution){
		for(var y = yTileScroll; y <= yTileScroll+yTilesOnScreen; y+=resolution){
			if(x < 0 || x >= world.sizeX || y < 0 || y >= world.sizeY){	
				continue;
			}
			drawTile(world.tiles[x][y]);
		}
	}
	var t2 = new Date();
	timeDiff(t2,t1,"PROCESSING.js: Drawing world took ");
   	};
}

var processingInstance;
var overlay;
function drawWorld3(worldToDraw,sizeX,sizeY,scale)
{
	$("#newPlayer").empty();
	canvas = document.createElement("canvas");
	overlay = document.createElement("canvas");
	overlay.id = "overlay";
	canvas.id = "canvas";
	overlay.width = canvas.width = window.innerWidth;
    overlay.height = canvas.height = window.innerHeight;

	$("#newPlayer").append(overlay).append(canvas);
    cctx = overlay.getContext("2d"); 
 	// attaching the sketchProc function to the canvas
	processingInstance = new Processing(canvas, sketchProc);
	//initGL();

	//repaint2(worldToDraw);
}

function fetchRandomName(gender)
{
	/*This is far too slow. Need an internal resource to fetch from. Not allowed to use behindthename's db anyways*/
	gender = (gender == undefined) ? "m" : gender;
	var a = [];
	$.get("http://www.behindthename.com/php/browse.php?type_gender=1&operator_gender=&value_gender[]=masculine&type_usage=1&operator_usage=&value_usage[]=french&page=2", function(data)
	{
		t = $(data.responseText);
		$("#temp").html(data.responseText);
		$("#temp").html($("#temp .body"));
		look2 = $("#temp div strong a:first-child").each(function(i){
			var name = $(this).text();
			name = name.replace(/\([0-9]\)/g,"");
			name = name.toLowerCase();
			name = name[0].toUpperCase() + name.substr(1);
			name = $.trim(name);
			a.push(name);
		});
		$("#temp").removeClass("hidden").empty();
		$(".window").addClass("hidden");
		$("#temp").append($("<textarea></textarea>").css("background-color","black").attr("id","temp2").attr("cols",1).attr("rows",a.length));
		for(var i = 0; i < a.length; i++){
			$("#temp2").text($("#temp2").text() + a[i] + "\n");
		}
	});
}

/*Generates a smaller world.*/
function generateBattlefield(){
	/*  TODO 
	 * 	 Make sure that it is always possible to place units for both participants
	 *	 Modify world generation to ensure that there are fewer lakes and mountains on battlefields
	 *   Make sure that no unit will be unable to move from one part of the battlefield to another
	 *   Make sure that the size of the battlefield is alright
	 *   Generate battlefield from parts of the world
	 *   Generate unit placement for AI as well as basic pathfinding.
	 */ 
	 
	var bf = new World();
	bf.tileSize = 12;
	var w = $(window).width();
	var h = $(window).height();
	bf.sizeX = w/bf.tileSize;
	bf.sizeY = h/bf.tileSize;
	bf.tiles = generateWorld(bf.sizeX,bf.sizeY);	
	return bf;
}

function getTileFromId(id){
	var x = id.substring(0, id.indexOf(","));
	var y = id.substring(id.indexOf(",") + 1);
	return world.tiles[x][y];
}

function tileClicked(worldTile)
{
	/*Zoom in if in world map mode*/
	/*if(!mode)
	{
		center = worldTile.globalPosition;
		mode = true;
		drawWorld2($("#newPlayer").svg('get'),world.sizteX, world.sizeY, tileSize);
		return;
	}
	*/
	/*Else, if in local map mode:*/
	updateTileInfo(worldTile);
	$("#tileInfo").show();
	/*Make sure that the info is entirely in view. Move camera so that tile is centered if necessary*/
	//$("#tileInfo").css("left", (worldTile.globalPosition.x+1) * tileSize);
	//$("#tileInfo").css("top", worldTile.globalPosition.y * tileSize - 150);
	
	/*If double click*/
	//tField = areas[worldTile.type][worldTile.field];
	//alert(worldTile.field.tiles.length + " " + worldTile.field.id);
	//tField = areas[worldTile.field];
	var tField = worldTile.field;
	changeOverlayCanvas(function(x,y){
		if(world.tiles[x][y].field == tField && world.tiles[x][y].borders != null && world.tiles[x][y].borders.length > 0){
			return 'rgba(10,10,40,0.3)';
		}
		else return 'rgba(0,0,0,0)';
	}, true);
	return;/*
	if(selected != undefined){
	selected.setAttribute("stroke", selected.getAttribute("fill"));
	}
	selected = tile;	
	tile.setAttribute("stroke", "yellow"); 
	$(tile).addClass("selected");	
	*/
}

function tileClick(evt){
	var tile = evt.target;
	followT = tile;
	tileClicked(getTileFromId(tile.id));
}

function constructEvent(event)
{
	var viewer = $("#eventViewer");
	viewer.append($("<div></div>").text(event.text()));
	viewer.append("<div class='close'>close</div>");
}

function statsScreen()
{
	var viewer = $("#eventViewer");
	viewer.append($("<div></div>").text(nrTiles + " tiles\n"));
	viewer.append("Water:" + (Math.round(100*(types["water"]) / (world.sizeX*world.sizeY))) + "% \n");
	viewer.append("Grass:" + Math.round(100*types["grass"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("Forest:" + Math.round(100*types["forest"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("Mountain:" + Math.round(100*types["mountain"] / (world.sizeX*world.sizeY)) + "% \n");
	viewer.append("<div class='close'>close</div>");
}

function showPerson(person){
	//	__________
	//	|portrait|
	//	|		 |
	//	|________|
	//	FULL NAME
	//
	//but for now...
	return $("<div>").addClass("personName").text(person.fname + " " + person.sname);
}

function constructMenu(menuType)
{
 var menu = $("#MenuDisplay");
 if(menuType == "options")
 {
	var exportGame = $("<div></div>").attr("id","exportGame").addClass("options").text("Export Game");
	var setResolution = $("<div></div>").attr("id","setResolution").addClass("options").text("Set Tile Size");
	var reloadGame = $("<div></div>").attr("id","reloadGame").addClass("options").text("Reload World");
	var battleTest = $("<div></div>").attr("id","battleTest").addClass("options").text("Generate Battlefield");
	menu.append(exportGame).append(reloadGame).append(setResolution).append(battleTest);
 }
 else if(menuType == "dynasty"){
		showDynasty();
		$("#FamilyTree").show();
 }
 else if(menuType == "filter")
 {
	var population = $("<div></div>").attr("id","populationFilter").addClass("filter").text("Show Population");
	var wealth = $("<div></div>").attr("id","wealthFilter").addClass("filter").text("Show Wealth");
	var food = $("<div></div>").attr("id","foodFilter").addClass("filter").text("Show Food");
	var heightMap = $("<div></div>").attr("id","heightMapFilter").addClass("filter").text("Show Height Map");
	menu.append(population).append(wealth).append(heightMap).append(food);
 }
 else if(menuType == "stats")
 {
	var stats = $("<div></div>").attr("id","stats").addClass("stats").text("Stats");
	var famtree = $("<div></div>").attr("id","familytree").addClass("stats").text("Family Tree");
	var reloadGame = $("<div></div>").attr("id","reloadGame").addClass("options").text("Habla habla");
	menu.append(stats).append(famtree).append(reloadGame);
 }
 else if(menuType == "events")
 {
	var event1 = $("<div></div>").attr("id","event1").addClass("event").text("Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.");
	var event2 = $("<div></div>").attr("id","event2").addClass("event").text("Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?");
	menu.append(event1).append(event2);
 }
 menu.append("<div class='close'>close</div>");
}

function zoomInOn(tile,event){
	var xShift, yShift;
	if(event.pageX == undefined){
		zoomLevel = event/scale;
		zoomState = true;
		scale = event;
		var xShift = w/2;
		var yShift = h/2;
	}
	else{
		scale = world.tileSize*zoomLevel;
		var xShift = event.pageX;
		var yShift = event.pageY;
	}
	
	xScroll = tile.globalPosition.x*scale - xShift;
	yScroll = tile.globalPosition.y*scale - yShift;

	if(xScroll > (world.sizeX*scale-w)) xScroll = (world.sizeX*scale-w);
	if(xScroll < 0) xScroll = 0;
	if(yScroll > (world.sizeY*scale-h)) yScroll = (world.sizeY*scale-h);
	if(yScroll < 0) yScroll = 0;	
	repaint2();
}

function keyBindings(){
	$(document).bind('mousewheel', function(e){
		$("#tileInfo").hide();
		if(e.wheelDelta > 0){
			zoomLevel += 1;
		}
		else{
			zoomLevel -= 1;
		}
		if(zoomLevel > zoomMax){
			zoomLevel = zoomMax;
		}
		else if(zoomLevel < zoomMin){
			zoomLevel = zoomMin;
		}
		zoomState = true;
		if(zoomState){
			if(zoomLevel == 1){
				xScroll = 0;
				yScroll = 0;
			}
			zoomInOn(tileFromEvent(e), e);
		}
		else{
			xScroll = 0;
			yScroll = 0;
			repaint2();
		}
	});
	$("#newPlayer").live(uiClick, function(e){
		//$("#tileInfo").hide();
		//zoomState = !zoomState;
		select(tileFromEvent(e));
		
		/*if(zoomState){
			zoomInOn(tileFromEvent(e));
		}
		else{
			xScroll = 0;
			yScroll = 0;
			repaint2();
		}*/
	});
	$(document).delegate("*", 'keydown', function(e){
		switch(e.keyCode){
			case 32:
				zoomState = !zoomState;
				repaint();
				break;
			case 37:
				dx = -1;
				break;
			case 38:
				dy = -1;
				break;
			case 39:
				dx = 1;
				break;
			case 40:
				dy = 1;
				break;
			}
	});
	$(document).delegate("*", 'keyup', function(e){
		switch(e.keyCode){
			case 37:
				dx = 0;
				break;
			case 38:
				dy = 0;
				break;
			case 39:
				dx = 0;
				break;
			case 40:
				dy = 0;
				break;
			}
	});

	$(".header").live(uiClick, function(event){
		if($(this).attr("menuType") != undefined){
			$("#MenuDisplay").empty();
			constructMenu($(this).attr("menuType"));
			$("#MenuDisplay").show().removeClass("hidden");
		}
	});
	$(".close").live(uiClick, function(event){
		$(this).parent().hide();//addClass("hidden");
	});
	$(".event").live(uiClick,function(event)
	{                                  
		/*open event in eventViewer*/
		var top = 0.15*($("body").height());
		var left = 0.15*($("body").width());
		$("#eventViewer").css("top",top).css("left",left).empty().removeClass("hidden");
		constructEvent($(this));
	});
	$("#stats").live(uiClick,function(event)
	{                                  
		/*open stats in eventViewer*/
		var top = 0.15*($("body").height());
		var left = 0.15*($("body").width());
		$("#eventViewer").css("top",top).css("left",left).empty().removeClass("hidden");
		statsScreen();
		
	});
	$("#populationFilter").live(uiClick, function(event){
		filter = !filter;
		if(filter)
		{
			changeOverlayCanvas(function(x,y){
				if(world.tiles[x][y].population != 0)
				{
					return 'rgba('+Math.floor(100+155*world.tiles[x][y].population/largestCity)+',75,75,0.5)';
				}
				else{
					return 'rgba(0,0,0,0)';
				}
			});
		}
		else
		{
			changeOverlayCanvas(function(x,y){
					return 'rgba(0,0,0,0)';
			});
		}
		//drawWorld2($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize);
	});
	$("#foodFilter").live(uiClick, function(event){
		changeOverlay($("#newPlayer").svg("get"),world.sizeX,world.sizeY,tileSize, function(x,y){
			var depth = world.tiles[x][y].depth;
			return 'rgba('+depth*10+','+depth*10+','+depth*10+',1)';
		});
	});
	$("#heightMapFilter").live(uiClick, function(event){
		changeOverlay($("#newPlayer").svg("get"),world.sizeX,world.sizeY,tileSize, function(x,y){
			var height = world.tiles[x][y].height;
			height += Math.abs(minHeight);
			height /= maxHeight;
			height *= 100;
			height = Math.round(height);
			return 'rgba('+height+','+height+','+height+',1)';
		});
	});
	$("#canvas,#overlay").live(uiClick,function(event)
	{
		tEv = event;
		//id = {x:Math.floor(event.pageX/tileSize),y:Math.floor(event.pageY/tileSize)};
		tileClicked(tileFromEvent(event));
	});
	$("#battleTest").live(uiClick, function(event){
		var bf = generateBattlefield();
		drawWorld3(bf);
	});
	/*$("#DateHeader").hover(
		function () {
			$(this).text("Next Turn");
		}, 
		function () {
			$(this).text("Year " + year);
		});*/
	$("#TurnHeader").live(uiClick, function(event){
		nextTurn();
		updateDateHeader();
	});
}

function nextTurn(){
	season++;
	if(season > 3){
		season = 0;
		year++;
	}
	repaint2();
	//year += yearInc;
	//$("#Loading").show();	
}

function newWorld(res){//deprecated
	alert("Generating new world with more detail, this make take some time");
	h = $(window).height();
	w = $(window).width();
	tileSize = res;
	var sizeX = w/tileSize;
	var sizeY = h/tileSize;
	world = new World();	
	world.tiles = generateWorld(sizeX,sizeY);
	world.sizeX = world.tiles.length;
	world.sizeY = world.tiles[0].length;
	$("#newPlayer").svg('get').clear();
	drawWorld2($("#newPlayer").svg('get'),world.sizeX, world.sizeY, tileSize);
}


function updateDateHeader(){
	$("#DateHeader").text(year+":"+seasons[season]);
}

function loadWorld(location){
	world = new World();
	world = jsonTo(sessionStorage[location]);
	rebuild();
}

function continueGame(){
	alert("Currently not supported");
	world = sessionStorage["world"];
}
var loadGame = options = continueGame;

function openInitMenu(createWorld){
	$("#NewGameMenu").empty();
	$("#newPlayer").live(uiClick, function(e){}); //this is stupid...
	var quickStart = $("<div>").addClass("selectable").attr("id","quickStart").click(start).text("Start Playing");
	var newGameBtn = $("<div>").addClass("selectable").attr("id", "newGame").click(newGame).text("New Game With Options");
	var continueGameBtn = $("<div>").addClass("selectable").attr("id", "continueGame").click(continueGame).text("Continue Game");
	var loadGameBtn = $("<div>").addClass("selectable").attr("id", "loadGame").click(loadGame).text("Load Game");
	var optionsBtn = $("<div>").addClass("selectable").attr("id", "options").click(options).text("Options");
	$("#NewGameMenu").append(quickStart).append(newGameBtn).append(loadGameBtn).append(optionsBtn);
	if(saveExists()){
		$("#NewGameMenu #newGame").after(continueGameBtn);
	}
	startLoading();
	if(createWorld == undefined || createWorld){
		craftNewWorld();
	}
	else{
		$("#newPlayer").show();
	}
}

function tileFromEvent(event){
	//TODO doesn't work with zoom and scroll.
	var x = Math.floor(event.pageX/(scale) + xScroll/scale);
	var y = Math.floor(event.pageY/(scale) + yScroll/scale);
	return world.tiles[x][y];
}

function select(tile){
	if(selected != undefined){
		selected.selected = false;
		drawSingleTile(cctx, selected.globalPosition.x, selected.globalPosition.y, getColorForTile(selected));
	}
	selected = tile;
	tile.selected = true;
	drawSingleTile(cctx, tile.globalPosition.x, tile.globalPosition.y, "rgba(255,255,0,0.4)");
	//repaint2();
}

function characterGen(){
	var player;
	if(world.dynasty != undefined && world.dynasty.root != undefined){
		player = world.dynasty.root;
	}
	else{
		alert("error");
		//player = new generatePerson();
		//createDynasty(player); //move these to newGame()
		//generateResources();
		//determineValue();
		//generatePopulation();
		//drawWorld3();
	}
	var firstName = $("<input></input>").addClass("nLoc").attr("id", "fNameInput").val(player.fname).change(
		function(){
			world.dynasty.root.fname = $(this).val();
		});
	var lastName = $("<input></input>").addClass("nLoc").attr("id", "lNameInput").val(player.sname).change(
		function(){
			world.dynasty.root.sname = $(this).val();
		});
	var randomFName = $("<div>").addClass("selectable").addClass("nLoc").text("Random First Name").click( function(){$("#fNameInput").val(world.dynasty.root.fname = generateFirstName($("#cGender").text()));});
	var randomLName = $("<div>").addClass("selectable").addClass("nLoc").text("Random Surname").click( function(){$("#lNameInput").val(world.dynasty.root.sname = generateSurName());});
	var genderInput =  $("<span>").text(player.gender).attr("id","cGender");
	var genderChoice = $("<span>").addClass("selectable").text("Switch").click(function(e){
		if($("#cGender").text()=="Male"){world.dynasty.root.gender="Female";$("#cGender").text("Female");}
			else{world.dynasty.root.gender="Male";$("#cGender").text("Male");}
			});
	var genderOptions = $("<div>").addClass("nLoc").append($("<span>").text("Gender: ").append(genderInput).append(genderChoice));
	var traitsSet = $("<div>").addClass("selectable").addClass("nLoc").text("Show and Manipulate Traits");
	var locationSet = $("<div>").addClass("selectable").attr("id","lSet").text("Set Starting Location").click( function(){
		$(this).click( function(){
			$(this).text("Set Starting Location");
			$("#newPlayer").unbind();
			$("#NewGameMenu").draggable('destroy').css({"height":"","left":"","right":"","bottom":0,"right":0});
			$("#Title, .nLoc").show();
		});
		$(this).text("Click on a settlement (orange tiles). Click here to return.").css("font-size","20px");
		$("#NewGameMenu").css("height","10%").draggable();
		$("#Title, .nLoc").hide();
		$("#newPlayer").click( function(e){
			var loc = tileFromEvent(e);
			if(loc.type == "settlement"){
				world.dynasty.root.location = loc;
				movePersonTo(world.dynasty.root,loc);
				select(tileFromEvent(e));
				$("#lSet").text("Click here to accept");
			}
			else{
				alert("Please click on a settlement");
			}
		});
	});
	var startGame = $("<div>").addClass("selectable").addClass("nLoc").text("Start Playing").click( function(){createDynasty(world.dynasty.root);start();});
	var back = $("<div>").addClass("selectable").addClass("nLoc").text("Back to World Creation").click( function(){createDynasty(world.dynasty.root);newGame();});
	$("#NewGameMenu").empty().append(genderOptions).append(firstName).append(lastName).append(randomFName).append(randomLName)
	.append(traitsSet).append(locationSet).append(startGame).append(back);
}

function editWorld(location){
	if(location == undefined){
		location = $("#NewGameMenu");
		
	}
	
	location.show().draggable();
	location.find("*").addClass("temp").addClass("hidden");
	$.each(tileTypes, function(i,val){
		var name = val[0].toUpperCase()+val.substr(1);
		var cssO = {"background-color":getColorFromType(val),"font-size":"20px"}; 
		location.append(
			$("<div>").addClass("rtemp").append($("<span>").addClass("smallSquare").text(name + " Tile").css(cssO))
					  .append($("<span>").addClass("smallSquare").text(name + " Formation").css(cssO)));
	});
	var importWorld = $("<div>").addClass("selectable").addClass("rtemp").text("Import World").click( function(e){alert("...");});
	var exportWorld;
	var blankSlate = $("<div>").addClass("selectable").addClass("rtemp").text("Cover World With Grass").click( function(e){
		//are you sure?
		for(var x=0;x<world.sizeX;x++){
			for(var y=0;y<world.sizeY;y++){
				world.tiles[x][y].type = "grass";
				world.tiles[x][y].depth = 0;
			}
		}
		repaint2();
	});
	var done = $("<div>").addClass("selectable").addClass("rtemp").text("Done").click( function(e){
	location.find(".rtemp").remove();
	location.find(".temp").removeClass("temp").removeClass("hidden");
	location.draggable("destroy").css({"left":"","top":""});
	$("#Title").show(); //only do this if it was actually shown before..
	});
	location.append(importWorld).append(blankSlate).append(done);
}

function newGame(){
	var setSeed = $("<div>").addClass("selectable").attr("id", "setSeed")
				.click(function(e){$(".seedSet").show();$(this).hide();}).text("Set Seed");
	var seedInput = $("<input></input>").addClass("selectable").addClass("seedSet").val(seed).attr("id", "seed").hide();
	var seedDiscard = $("<span>").hide().addClass("selectable").addClass("seedSet")
		.click( function(e){$("#seed").val(seed)}).text("Discard");
	var seedTime = $("<span>").hide().addClass("selectable").addClass("seedSet")
		.click( function(e){$("#seed").val("");seed = undefined;}).text("Use Time");
	var seedConfirm = $("<span>").hide().addClass("selectable").addClass("seedSet").text("Set Seed")
		.click( function(e){var t = $("#seed");seed = t.val();$(".seedSet").hide();$("#setSeed").show();});

	//var screensize = $("<div>").attr("id", "screensize").text("Change Screen Size").bind(click, function(e){if(resizeable){$(this).text("Change Screen Size");}else{$(this).text("Go ahead and resize it");}risezable=!resizeable;});
	var tilesizeInput = $("<input></input>").addClass("selectable").attr("id","tsinput").val(world.tileSize).hide().bind("keyup",function(e){
		if($(this).val().match(/[^0-9]/)){
			$(this).addClass("error");
		}
		else{
			$(this).removeClass("error");
		}
	//check if e is enter and no error. then set tilesize
	});
	var tilesize = $("<div>").addClass("selectable").attr("id", "tilesize").text("Change Tile Size").click( function(e){
		if($(this).attr("active") == "true"){
		 $(this).attr("active","false").text("Change Tile Size"); tileSize = $("#tsinput").hide().val();
		}
		else{
		 $(this).attr("active","true").text("Set Tile Size!"); $("#tsinput").val(tileSize).show();
		}
	});
	
	var regenerate = $("<div>").addClass("selectable").attr("id", "regenerate").text("Generate New World").click( function(e){craftNewWorld(tileSize,seed);});
	var edit = $("<div>").addClass("selectable").attr("id", "edit").text("Edit or Import World").click( function(e){editWorld($(this).parent());});
	var charGen = $("<div>").addClass("selectable").attr("id", "start").text("Accept World").click( function(e){characterGen();});
	var back = $("<div>").addClass("selectable").attr("id","back").text("Back To Menu").click( function(e){openInitMenu(false);});
	$("#NewGameMenu").empty().append(setSeed).append(seedInput).append(seedTime).append(seedConfirm).append(seedDiscard)
			.append(tilesizeInput).append(tilesize).append(regenerate).append(edit).append(charGen).append(back);
}

function loadJSFile(file){
	$("head").append($("<script>").attr("type","text/javascript").attr("src",file));
}

function selectMode(mode){
	if(mode != undefined){
		loadJSFile("scripts/" + mode);
		openInitMenu();
	}
	var header = $("<div>").text("Select Mode").css("text-align","left");
	//var bgImage1 = $("<image>").attr("id","bgImage1").css({"position":"absolute", "opacity":0.6, "top":0})
	//	.attr("src","scripts/res/colonization.jpg").hide();
	//var bgImage2 = $("<image>").attr("id","bgImage2").css({"position":"absolute", "opacity":0.6, "top":0})
	//	.attr("src","scripts/res/dynasty.jpg");
	//$("body").append(bgImage1).append(bgImage2);
	var colonization = $("<div>").addClass("selectable").text("Colonization").click( function(){mode = "colonization";loadJSFile("scripts/colonization.js"); openInitMenu();})
		.hover(function(){$("#bgImage1").show(); $("#bgImage2").hide();});
	var dynasty = $("<div>").addClass("selectable").text("Dynasty").click( function(){mode = "dynasty";//loadJSFile("scripts/dynasty.js"); 
		openInitMenu();})
		.hover(function(){$("#bgImage2").show(); $("#bgImage1").hide();});
	$("#NewGameMenu").empty().append(header).append(colonization).append(dynasty);
}

function init(){
		/*Runs at startup*/
	$(".window").hide();
	$("#Loading").hide();
	h = $(window).height();
	w = $(window).width();

	$("#tileInfo").draggable().css("position","");
	$("#FamilyTree").hide();
		/*Platform specifics*/
	var ua = navigator.userAgent;
	iOSDevice = ua.match(/iPad|iPhone/i);
	m = new MersenneTwister();
	if(iOSDevice){
		$("#NewGameMenu").css({"width":"33%","height":"60%"});
		$("#MenuHeaders").css("max-width","60%");
		$("#MenuDisplay").css("width","20%");
		$("#Title").css("height","28%");
	}
    uiClick = (iOSDevice) ? "touchstart" : "click";
	uiHover = (iOSDevice) ? "touchstart" : "mouseover";
	uiHoverEnd = (iOSDevice) ? "touchend" : "mouseout";
	uiDblClick = (iOSDevice) ? "double-tap" : "dblclick";
	setWorldSize((iOSDevice) ? 8 : 3);
    initFilters();
	
		/*Look a URL to see if parameters have been sent*/
	var showMap = true;
	var i = getUrlVar();
	if(i == "start"){
		return craftNewWorld();
	}
	else if(i == "continue"){
		return continueGame();
	}
	else if(i == "debug"){
		debug = true;
	}
	else if(i == "simple"){
		showMap = false;
	}
	selectMode();
	//openInitMenu(showMap);	
}

var worldSize = {
	"tiny" : 8,
	"small" : 4,
	"medium" : 3,
	"large" : 2,
	"huge" : 1,
};

function setWorldSize(size){
	tileSize = scale = size;
	sizeX = Math.floor(w/tileSize);
	sizeY = Math.floor(h/tileSize);	
}

function print(s){console.log(s);}

function saveExists(){
	return false;
}

function start(){
	/*Starts the game*/
	/*All world generation should already be done by this point*/
	
	$(".init").hide();
	modeInit();
	var pos = world.dynasty.root.location;
	zoomInOn(world.tiles[pos.x][pos.y], 24);
	//fog = true;
	range = 20;
	//$("#Loading").show();
	keyBindings();

	maxHeight = -1;
	minHeight = 1;
	
	if(mode=="colonization"){
		$("#DynastyHeader").text("Colony");
	}
	
	filter = false;
	center = 250;
	//keyBindings();
	$(".window").show();
	$("#eventViewer").addClass("hidden");
	nrTiles = 0;
	//p = generatePerson("a", "Female");
	//displayPerson(p);
	types = {"water":0,"mountain":0,"forest":0,"grass":0,"sand":0};
	for(var x = 0; x < world.sizeX; x++){
		for(var y = 0;y < world.sizeY;y++){
			types[world.tiles[x][y].type]++;
			nrTiles++;
		}
	}
	updateDateHeader();
}

function updateLoading(){
	loadingDots++;
	if(loadingDots > 3){
		loadingDots = 1;
	}
	var dots = $("#loadingDots").empty();
	for(var i = 0; i < loadingDots; i++){
		dots.append(".");
	}
}

function startLoading(){
	$("#Loading").show();
	loading = true;
}
function stopLoading(){
	$("#Loading").hide();
	loading = false;
}

var loadingDots = 0;
var ticks = 0;
var loading = false;
var loadCounter = 0;
function tick(){
    if(loading != undefined && loading){
        if(loadCounter == undefined || loadCounter % 300 == 0){
            updateLoading();
            loadCounter = 1;
        }
        loadCounter++;
    }
    if(world == undefined) return setTimeout(tick,60/1000);;
	var prevX = xScroll;
	var prevY = yScroll;
	xScroll += dx*scrollRate;
	yScroll += dy*scrollRate;
	if(xScroll > (world.sizeX*scale-w)) xScroll = (world.sizeX*scale-w);
	if(xScroll < 0) xScroll = 0;
	if(yScroll > (world.sizeY*scale-h)) yScroll = (world.sizeY*scale-h);
	if(yScroll < 0) yScroll = 0;
	if(//zoomState && 
	(prevX-xScroll != 0 || prevY-yScroll != 0)){
		repaint2();
	}
	ticks++;
    setTimeout(tick,60/1000);
}

$(document).ready(function() { //runs when site is ready.
    init();
	tick();
	$(window).unload(function(event) {
		//save world into sessionStorage.
		//sessionStorage['world'] = JSON.stringify(world);
    });
});
